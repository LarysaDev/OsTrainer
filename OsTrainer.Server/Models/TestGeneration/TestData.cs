namespace OsTrainer.Server.Models.TestGeneration
{
    public class TestData
    {
        public List<TestQuestion> Questions { get; set; }

        public TestData()
        {
            Questions = new List<TestQuestion>()
            {
                //FCFS
                new TestQuestion { Id = 1, AlgorithmId = 1, QuestionText = "Яка основна характеристика алгоритму FCFS?", Options = new List<string> { "Непереривний", "Преривний", "Циклічний", "На основі пріоритету" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 2, AlgorithmId = 1, QuestionText = "Алгоритм FCFS найкраще підходить для:", Options = new List<string> { "Задач з високим пріоритетом", "Задач з низьким пріоритетом", "Послідовних задач", "Одноразових задач" }, CorrectOptionIndex = 2 },
                new TestQuestion { Id = 3, AlgorithmId = 1, QuestionText = "Який процес обробляється першим у FCFS?", Options = new List<string> { "Процес з найменшим часом виконання", "Процес, що надійшов першим", "Процес з найвищим пріоритетом", "Процес з мінімальним часом очікування" }, CorrectOptionIndex = 1 },
                new TestQuestion { Id = 4, AlgorithmId = 1, QuestionText = "Яка проблема часто виникає з FCFS?", Options = new List<string> { "Затримка (Starvation)", "Голодання", "Справедливий розподіл", "Конкуренція ресурсів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 5, AlgorithmId = 1, QuestionText = "FCFS означає:", Options = new List<string> { "First-Come, First-Served", "Fast-Computing, Fair-Serving", "Fixed-Cost, Free-Solution", "First-Come, Fair-Service" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 6, AlgorithmId = 1, QuestionText = "Як обробляються процеси у FCFS?", Options = new List<string> { "На основі пріоритету", "В порядку надходження", "По черзі", "На основі часу виконання" }, CorrectOptionIndex = 1 },
                new TestQuestion { Id = 7, AlgorithmId = 1, QuestionText = "Основна перевага FCFS?", Options = new List<string> { "Простота", "Продуктивність", "Справедливість", "Мінімальні затримки" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 8, AlgorithmId = 1, QuestionText = "У якому випадку FCFS працює ефективно?", Options = new List<string> { "Для великих задач", "Для коротких задач", "Для одночасних процесів", "Для послідовних задач" }, CorrectOptionIndex = 3 },
                new TestQuestion { Id = 9, AlgorithmId = 1, QuestionText = "Який недолік має FCFS?", Options = new List<string> { "Голодання", "Повільне виконання", "Довгий час очікування", "Високі ресурси" }, CorrectOptionIndex = 2 },
                new TestQuestion { Id = 10, AlgorithmId = 1, QuestionText = "Алгоритм FCFS вимагає:", Options = new List<string> { "Високий пріоритет", "Простий планувальник", "Комплексний планувальник", "Динамічний розподіл часу" }, CorrectOptionIndex = 1 },
                new TestQuestion { Id = 11, AlgorithmId = 1, QuestionText = "Чи дозволяє FCFS переривання процесів?", Options = new List<string> { "Так", "Ні", "Залежить від задачі", "Лише для коротких задач" }, CorrectOptionIndex = 1 },
                new TestQuestion { Id = 12, AlgorithmId = 1, QuestionText = "FCFS найкраще підходить для задач:", Options = new List<string> { "З високим пріоритетом", "Послідовних", "Непереривних", "Коротких" }, CorrectOptionIndex = 1 },
                new TestQuestion { Id = 13, AlgorithmId = 1, QuestionText = "Слабкість FCFS в:", Options = new List<string> { "Час очікування", "Простота", "Продуктивність", "Використання ресурсів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 14, AlgorithmId = 1, QuestionText = "FCFS призводить до:", Options = new List<string> { "Простого розподілу ресурсів", "Справедливості", "Голодання", "Непереривного часу" }, CorrectOptionIndex = 2 },
                new TestQuestion { Id = 15, AlgorithmId = 1, QuestionText = "Які задачі отримують перевагу у FCFS?", Options = new List<string> { "Задачі з коротким часом", "Пріоритетні задачі", "Задачі, що надійшли першими", "Задачі з великим часом" }, CorrectOptionIndex = 2 },

                //Round Robin
                new TestQuestion { Id = 16, AlgorithmId = 2, QuestionText = "Що таке часове квантування у Round Robin?", Options = new List<string> { "Обмеження часу для кожного процесу", "Час початку процесу", "Час завершення процесу", "Час між запусками процесів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 17, AlgorithmId = 2, QuestionText = "Як розподіляються процеси в Round Robin?", Options = new List<string> { "За пріоритетом", "Циклічно по черзі", "Залежно від часу виконання", "Випадковим чином" }, CorrectOptionIndex = 1 },
                new TestQuestion { Id = 18, AlgorithmId = 2, QuestionText = "Round Robin найкраще підходить для:", Options = new List<string> { "Систем з високим пріоритетом", "Систем реального часу", "Багатокористувацьких середовищ", "Процесів з великим часом виконання" }, CorrectOptionIndex = 2 },
                new TestQuestion { Id = 19, AlgorithmId = 2, QuestionText = "Якщо процес не завершено протягом кванта часу в Round Robin, то:", Options = new List<string> { "Його переривають і поміщають в кінець черги", "Він продовжує виконання", "Його видаляють з черги", "Його час збільшується" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 20, AlgorithmId = 2, QuestionText = "Який основний недолік Round Robin?", Options = new List<string> { "Затримка процесів з високим пріоритетом", "Погане використання ресурсів", "Справедливий розподіл часу", "Зниження продуктивності" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 21, AlgorithmId = 2, QuestionText = "Round Robin забезпечує:", Options = new List<string> { "Пріоритетний доступ", "Циклічний доступ", "Доступ на основі часу очікування", "Випадковий доступ" }, CorrectOptionIndex = 1 },
                new TestQuestion { Id = 22, AlgorithmId = 2, QuestionText = "Яке значення має квантування часу у Round Robin?", Options = new List<string> { "Чим менше, тим кращий розподіл", "Чим більше, тим вища продуктивність", "Не має значення", "Залежить від часу виконання процесів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 23, AlgorithmId = 2, QuestionText = "Round Robin є прикладом:", Options = new List<string> { "Преривного планування", "Непереривного планування", "Пріоритетного планування", "Випадкового планування" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 24, AlgorithmId = 2, QuestionText = "Яка основна перевага Round Robin?", Options = new List<string> { "Справедливий розподіл часу", "Швидке виконання процесів", "Зниження затримок", "Пріоритетний доступ до ресурсів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 25, AlgorithmId = 2, QuestionText = "Як квантування часу впливає на продуктивність Round Robin?", Options = new List<string> { "Збільшує затримки", "Підвищує продуктивність", "Не впливає", "Забезпечує справедливий розподіл" }, CorrectOptionIndex = 3 },
                new TestQuestion { Id = 26, AlgorithmId = 2, QuestionText = "Що відбувається після завершення кванта часу в Round Robin?", Options = new List<string> { "Процес завершується", "Процес відправляється в кінець черги", "Процес отримує додатковий час", "Процес видаляється з черги" }, CorrectOptionIndex = 1 },
                new TestQuestion { Id = 27, AlgorithmId = 2, QuestionText = "Round Robin використовує квантування часу для:", Options = new List<string> { "Розподілу ресурсів", "Визначення пріоритету", "Забезпечення циклічного доступу", "Обмеження часу виконання" }, CorrectOptionIndex = 3 },
                new TestQuestion { Id = 28, AlgorithmId = 2, QuestionText = "Основна мета Round Robin:", Options = new List<string> { "Максимізація пріоритету", "Справедливий доступ до процесора", "Зменшення затримок", "Підвищення продуктивності" }, CorrectOptionIndex = 1 },
                new TestQuestion { Id = 29, AlgorithmId = 2, QuestionText = "Round Robin забезпечує процеси:", Options = new List<string> { "З рівним доступом до ресурсів", "З максимальним часом виконання", "З доступом на основі пріоритету", "З доступом на основі часу виконання" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 30, AlgorithmId = 2, QuestionText = "Яке середовище ідеально підходить для Round Robin?", Options = new List<string> { "Системи реального часу", "Мультизадачні системи", "Однозадачні системи", "Системи з високим пріоритетом" }, CorrectOptionIndex = 1 },

                //SJF (Non-preemptive)
                new TestQuestion { Id = 31, AlgorithmId = 3, QuestionText = "Що означає SJF у плануванні процесів?", Options = new List<string> { "Shortest Job First", "Shortest Job Forever", "Shortest Job Flow", "Shortest Jump First" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 32, AlgorithmId = 3, QuestionText = "Як процес обирається у SJF (Non-preemptive)?", Options = new List<string> { "З найкоротшим часом виконання", "З найвищим пріоритетом", "З найбільшим часом очікування", "У випадковому порядку" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 33, AlgorithmId = 3, QuestionText = "Який тип процесів виконується першим у SJF (Non-preemptive)?", Options = new List<string> { "Той, що має найкоротший час виконання", "Той, що має найвищий пріоритет", "Той, що має найстаріший час надходження", "Той, що має найменшу затримку" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 34, AlgorithmId = 3, QuestionText = "Основна перевага алгоритму SJF (Non-preemptive):", Options = new List<string> { "Зменшує загальний час виконання", "Збільшує пріоритет процесів", "Зменшує затримки для великих процесів", "Забезпечує циклічний доступ" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 35, AlgorithmId = 3, QuestionText = "Який основний недолік SJF (Non-preemptive)?", Options = new List<string> { "Схильний до ефекту затримки довгих процесів", "Не враховує час очікування", "Вимагає високих ресурсів", "Призводить до перевантаження" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 36, AlgorithmId = 3, QuestionText = "SJF (Non-preemptive) ідеально підходить для:", Options = new List<string> { "Коротких процесів з передбачуваним часом", "Процесів реального часу", "Випадкових процесів", "Високопріоритетних процесів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 37, AlgorithmId = 3, QuestionText = "Що станеться, якщо всі процеси мають однаковий час виконання у SJF?", Options = new List<string> { "Виконуються у порядку надходження", "Виконуються у випадковому порядку", "Виконуються на основі пріоритету", "Час очікування збільшується" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 38, AlgorithmId = 3, QuestionText = "SJF (Non-preemptive) базується на:", Options = new List<string> { "Часі виконання процесу", "Пріоритеті процесу", "Часі надходження процесу", "Системних налаштуваннях" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 39, AlgorithmId = 3, QuestionText = "Що відбувається з процесами з великим часом у SJF (Non-preemptive)?", Options = new List<string> { "Вони можуть чекати довше", "Вони мають вищий пріоритет", "Вони завжди виконуються першими", "Вони не виконуються" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 40, AlgorithmId = 3, QuestionText = "Чому SJF (Non-preemptive) не підходить для процесів реального часу?", Options = new List<string> { "Через затримку для довгих процесів", "Через необхідність високих ресурсів", "Через випадковий вибір процесів", "Через фіксовану чергу" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 41, AlgorithmId = 3, QuestionText = "Як алгоритм SJF (Non-preemptive) вирішує конфлікти між процесами з однаковим часом виконання?", Options = new List<string> { "Виконує у порядку надходження", "Виконує у випадковому порядку", "Виконує за пріоритетом", "Виконує на основі системного вибору" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 42, AlgorithmId = 3, QuestionText = "Що є основним фактором вибору процесу у SJF (Non-preemptive)?", Options = new List<string> { "Час виконання", "Час очікування", "Пріоритет", "Ресурси" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 43, AlgorithmId = 3, QuestionText = "SJF (Non-preemptive) забезпечує:", Options = new List<string> { "Мінімізацію часу виконання", "Максимальний пріоритет процесу", "Випадковий доступ до процесів", "Підвищення продуктивності для довгих процесів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 44, AlgorithmId = 3, QuestionText = "SJF (Non-preemptive) не дозволяє:", Options = new List<string> { "Переривання процесів", "Циклічний доступ до ресурсів", "Зменшення часу очікування", "Справедливий розподіл часу" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 45, AlgorithmId = 3, QuestionText = "Як SJF (Non-preemptive) впливає на час очікування коротких процесів?", Options = new List<string> { "Зменшує його", "Збільшує його", "Не впливає", "Рівномірно розподіляє його" }, CorrectOptionIndex = 0 },

                //SJF (Preemptive)
                new TestQuestion { Id = 46, AlgorithmId = 4, QuestionText = "Що означає 'Preemptive' у SJF (Preemptive)?", Options = new List<string> { "Можливість переривання процесу", "Виконання процесу до завершення", "Циклічне виконання процесів", "Пріоритет на основі очікування" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 47, AlgorithmId = 4, QuestionText = "Коли процес може бути перерваний у SJF (Preemptive)?", Options = new List<string> { "Коли з'являється процес з коротшим часом виконання", "Коли досягається часове обмеження", "Коли завершується цикл", "Коли немає інших процесів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 48, AlgorithmId = 4, QuestionText = "Який алгоритм також називається 'Shortest Remaining Time First'?", Options = new List<string> { "SJF (Preemptive)", "FCFS", "Round Robin", "Priority Scheduling" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 49, AlgorithmId = 4, QuestionText = "Основна перевага SJF (Preemptive):", Options = new List<string> { "Мінімізує середній час очікування", "Зменшує пріоритет низьких процесів", "Циклічно виконує всі процеси", "Збільшує час виконання" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 50, AlgorithmId = 4, QuestionText = "Який недолік має SJF (Preemptive)?", Options = new List<string> { "Відкладання процесів з великим часом", "Високе споживання ресурсів", "Нерівномірний розподіл часу", "Неможливість переривання" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 51, AlgorithmId = 4, QuestionText = "SJF (Preemptive) краще підходить для:", Options = new List<string> { "Короткочасних процесів з високим пріоритетом", "Процесів реального часу", "Довготривалих процесів", "Випадкових процесів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 52, AlgorithmId = 4, QuestionText = "Чим відрізняється SJF (Preemptive) від Non-preemptive?", Options = new List<string> { "Можливістю переривання процесу", "Підтримкою довгих процесів", "Циклічним виконанням", "Пріоритетом на основі надходження" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 53, AlgorithmId = 4, QuestionText = "У SJF (Preemptive), що станеться, якщо з'являється процес із коротшим часом?", Options = new List<string> { "Існуючий процес переривається", "Нічого не відбувається", "Процес продовжує виконуватися", "Процес завершується достроково" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 54, AlgorithmId = 4, QuestionText = "Як SJF (Preemptive) впливає на короткі процеси?", Options = new List<string> { "Зменшує час очікування для них", "Збільшує пріоритет", "Збільшує час виконання", "Рівномірно розподіляє ресурси" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 55, AlgorithmId = 4, QuestionText = "SJF (Preemptive) корисний, коли процеси:", Options = new List<string> { "Мають варіабельний час виконання", "Мають однаковий час", "Мають високий пріоритет", "Можуть перериватися лише вручну" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 56, AlgorithmId = 4, QuestionText = "Чому SJF (Preemptive) може спричинити затримки для довгих процесів?", Options = new List<string> { "Через часті переривання коротшими процесами", "Через нерівномірний розподіл пріоритетів", "Через нестачу ресурсів", "Через фіксований цикл виконання" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 57, AlgorithmId = 4, QuestionText = "Що є головним критерієм вибору процесу у SJF (Preemptive)?", Options = new List<string> { "Час, що залишився для виконання", "Пріоритет процесу", "Час надходження", "Кількість ресурсів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 58, AlgorithmId = 4, QuestionText = "Як SJF (Preemptive) обробляє нові процеси з коротким часом?", Options = new List<string> { "Перериває поточний процес", "Чекає завершення поточного процесу", "Додає їх у кінець черги", "Пропускає їх" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 59, AlgorithmId = 4, QuestionText = "Основна мета SJF (Preemptive):", Options = new List<string> { "Зменшити середній час очікування", "Збільшити час очікування для коротких процесів", "Забезпечити справедливий розподіл", "Оптимізувати використання ресурсів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 60, AlgorithmId = 4, QuestionText = "Який результат SJF (Preemptive) на продуктивність системи?", Options = new List<string> { "Покращення продуктивності для коротких процесів", "Збільшення часу виконання", "Зменшення пріоритету", "Нерівномірний розподіл" }, CorrectOptionIndex = 0 },

                //Priority(Non - preemptive)
                new TestQuestion { Id = 61, AlgorithmId = 5, QuestionText = "Що означає 'Non-preemptive' у алгоритмі пріоритету?", Options = new List<string> { "Процес не може бути перерваний", "Процес може бути перерваний", "Процеси виконуються в порядку надходження", "Всі процеси мають однаковий пріоритет" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 62, AlgorithmId = 5, QuestionText = "Який основний принцип алгоритму Priority (Non-preemptive)?", Options = new List<string> { "Виконання процесів за їх пріоритетом", "Виконання процесів у порядку надходження", "Виконання коротших процесів спочатку", "Виконання процесів із найменшою пам'яттю" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 63, AlgorithmId = 5, QuestionText = "Яка головна перевага алгоритму Priority (Non-preemptive)?", Options = new List<string> { "Гнучкість в обробці різних пріоритетів", "Простота реалізації", "Висока продуктивність", "Низьке споживання ресурсів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 64, AlgorithmId = 5, QuestionText = "Який недолік має алгоритм Priority (Non-preemptive)?", Options = new List<string> { "Можливість голодування низькоприорітетних процесів", "Складність реалізації", "Високе споживання ресурсів", "Невідомість часу виконання" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 65, AlgorithmId = 5, QuestionText = "При якій умові процес може отримати виконання в Priority (Non-preemptive)?", Options = new List<string> { "Коли всі процеси з вищим пріоритетом завершилися", "Коли система вільна", "Коли з'являється новий процес", "Коли процес запитує ресурси" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 66, AlgorithmId = 5, QuestionText = "У Priority (Non-preemptive) важливим є:", Options = new List<string> { "Визначення пріоритету для кожного процесу", "Тривалість виконання процесів", "Час надходження процесів", "Кількість запитів на ресурси" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 67, AlgorithmId = 5, QuestionText = "Яким чином обчислюється пріоритет процесів у Priority (Non-preemptive)?", Options = new List<string> { "На основі важливості або терміновості", "На основі часу виконання", "На основі кількості ресурсів", "На основі часу надходження" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 68, AlgorithmId = 5, QuestionText = "Які фактори можуть вплинути на визначення пріоритету в Priority (Non-preemptive)?", Options = new List<string> { "Важливість, терміновість, ресурси", "Тривалість, час надходження", "Кількість процесів", "Об'єм пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 69, AlgorithmId = 5, QuestionText = "Що станеться з процесом низького пріоритету в системі з високими пріоритетами?", Options = new List<string> { "Може стати голодним", "Завжди виконується першим", "Переривається", "Отримує додаткові ресурси" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 70, AlgorithmId = 5, QuestionText = "У якій ситуації алгоритм Priority (Non-preemptive) може бути найбільш ефективним?", Options = new List<string> { "Коли процеси мають чітко визначені пріоритети", "Коли всі процеси мають однаковий час виконання", "Коли системі потрібно швидко обробити всі процеси", "Коли процеси виконуються в циклі" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 71, AlgorithmId = 5, QuestionText = "Чи може алгоритм Priority (Non-preemptive) викликати проблеми з затримками?", Options = new List<string> { "Так, через голодування", "Ні, оскільки всі процеси виконуються", "Ні, всі пріоритети однакові", "Так, через нерівномірний розподіл" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 72, AlgorithmId = 5, QuestionText = "Яка стратегія управління може допомогти уникнути голодування в Priority (Non-preemptive)?", Options = new List<string> { "Введення часового обмеження для виконання", "Збільшення пріоритету низькоприорітетних процесів", "Зменшення пріоритету високоприорітетних", "Виконання всіх процесів в порядку надходження" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 73, AlgorithmId = 5, QuestionText = "Яка мета використання пріоритетів у алгоритмі Priority (Non-preemptive)?", Options = new List<string> { "Оптимізація ресурсо-витрат", "Зменшення часу очікування", "Забезпечення справедливості", "Підвищення продуктивності" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 74, AlgorithmId = 5, QuestionText = "Чим алгоритм Priority (Non-preemptive) відрізняється від SJF?", Options = new List<string> { "Своєю основною метою - пріоритетами", "Своїм підходом до переривання", "Своєю складністю реалізації", "Своїм використанням пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 75, AlgorithmId = 5, QuestionText = "У Priority (Non-preemptive) час виконання процесу залежить від:", Options = new List<string> { "Пріоритету процесу", "Тривалості процесу", "Часу надходження", "Кількості ресурсів" }, CorrectOptionIndex = 0 },

                //Priority(Preemptive)
                new TestQuestion { Id = 76, AlgorithmId = 6, QuestionText = "Що означає 'Preemptive' у алгоритмі пріоритету?", Options = new List<string> { "Процес може бути перерваний", "Процес не може бути перерваний", "Процеси виконуються в порядку надходження", "Всі процеси мають однаковий пріоритет" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 77, AlgorithmId = 6, QuestionText = "Яка основна перевага алгоритму Priority (Preemptive)?", Options = new List<string> { "Швидке реагування на високоприоритетні процеси", "Низьке споживання ресурсів", "Спростити управління пам'яттю", "Гнучкість в обробці процесів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 78, AlgorithmId = 6, QuestionText = "Який недолік має алгоритм Priority (Preemptive)?", Options = new List<string> { "Можливість збільшення часу виконання низькоприорітетних процесів", "Складність реалізації", "Невідомість часу виконання", "Високе споживання ресурсів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 79, AlgorithmId = 6, QuestionText = "Що відбувається з процесом, коли з'являється новий процес з вищим пріоритетом у Priority (Preemptive)?", Options = new List<string> { "Поточний процес переривається", "Нічого не відбувається", "Процес завершує виконання", "Процес ставиться в кінець черги" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 80, AlgorithmId = 6, QuestionText = "У яких випадках Priority (Preemptive) може бути менш ефективним?", Options = new List<string> { "Коли процеси мають високі пріоритети", "Коли процеси мають тривалий час виконання", "Коли всі процеси мають однакові пріоритети", "Коли система має обмежені ресурси" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 81, AlgorithmId = 6, QuestionText = "Яка стратегія управління може допомогти зменшити кількість переривань у Priority (Preemptive)?", Options = new List<string> { "Використання часових слів", "Скасування процесів", "Збільшення пріоритету низькоприорітетних процесів", "Зменшення часу виконання" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 82, AlgorithmId = 6, QuestionText = "У Priority (Preemptive) основна мета полягає в:", Options = new List<string> { "Забезпеченні швидкого виконання високоприоритетних процесів", "Оптимізації ресурсо-витрат", "Забезпеченні справедливості", "Зменшенні часу очікування" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 83, AlgorithmId = 6, QuestionText = "Які фактори впливають на виконання процесів у Priority (Preemptive)?", Options = new List<string> { "Пріоритет, час виконання, ресурси", "Тривалість, час надходження", "Кількість процесів", "Об'єм пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 84, AlgorithmId = 6, QuestionText = "Чи може алгоритм Priority (Preemptive) викликати проблеми з голодуванням?", Options = new List<string> { "Так, через часті переривання", "Ні, оскільки всі процеси виконуються", "Ні, всі пріоритети однакові", "Так, через нерівномірний розподіл" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 85, AlgorithmId = 6, QuestionText = "Яка мета використання пріоритетів у алгоритмі Priority (Preemptive)?", Options = new List<string> { "Оптимізація ресурсо-витрат", "Зменшення часу очікування", "Забезпечення справедливості", "Підвищення продуктивності" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 86, AlgorithmId = 6, QuestionText = "Які переваги має алгоритм Priority (Preemptive) в порівнянні з Non-preemptive?", Options = new List<string> { "Більш ефективне використання процесорного часу", "Простота реалізації", "Менше споживання пам'яті", "Менше часу на обробку процесів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 87, AlgorithmId = 6, QuestionText = "Що відбувається з низькоприорітетним процесом у системі з високими пріоритетами?", Options = new List<string> { "Може стати голодним", "Завжди виконується першим", "Переривається", "Отримує додаткові ресурси" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 88, AlgorithmId = 6, QuestionText = "У яких ситуаціях алгоритм Priority (Preemptive) може бути найбільш ефективним?", Options = new List<string> { "Коли потрібно швидко реагувати на важливі запити", "Коли всі процеси мають однаковий час виконання", "Коли системі потрібно швидко обробити всі процеси", "Коли процеси виконуються в циклі" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 89, AlgorithmId = 6, QuestionText = "Що може викликати проблеми з продуктивністю в алгоритмі Priority (Preemptive)?", Options = new List<string> { "Часті переривання і зміни контексту", "Довгі процеси", "Великі обсяги пам'яті", "Малий обсяг даних" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 90, AlgorithmId = 6, QuestionText = "Чи впливають часові слоти на виконання процесів у Priority (Preemptive)?", Options = new List<string> { "Так, вони визначають частоту переривань", "Ні, це не має значення", "Ні, час виконання процесів завжди фіксований", "Так, вони визначають порядок виконання" }, CorrectOptionIndex = 0 },

                //FIFO
                new TestQuestion { Id = 91, AlgorithmId = 7, QuestionText = "Що означає 'FIFO' у контексті заміщення сторінок?", Options = new List<string> { "Перший зайшов, перший вийшов", "Сторінка з найменшим пріоритетом видаляється", "Сторінка з найбільшим часом доступу видаляється", "Всі сторінки залишаються у пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 92, AlgorithmId = 7, QuestionText = "Яка основна ідея FIFO алгоритму?", Options = new List<string> { "Видаляти сторінку, яка перебуває у пам'яті найдовше", "Видаляти сторінку, яка найменше використовується", "Видаляти сторінку з найвищим пріоритетом", "Зберігати всі сторінки у пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 93, AlgorithmId = 7, QuestionText = "Який недолік має алгоритм FIFO?", Options = new List<string> { "Можливість аномалії Бела", "Складність реалізації", "Високе споживання ресурсів", "Неможливість обробки великих даних" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 94, AlgorithmId = 7, QuestionText = "Як вибирається сторінка для видалення у FIFO?", Options = new List<string> { "Сторінка, яка була завантажена найраніше", "Сторінка з найвищим пріоритетом", "Сторінка, яка найменше використовується", "Сторінка, яка завантажена останньою" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 95, AlgorithmId = 7, QuestionText = "Чи можлива аномалія Бела у FIFO?", Options = new List<string> { "Так, якщо збільшується кількість кадрів", "Ні, це неможливо", "Так, у разі використання часових слів", "Ні, це трапляється тільки у інших алгоритмах" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 96, AlgorithmId = 7, QuestionText = "Який основний недолік алгоритму FIFO порівняно з іншими алгоритмами заміщення сторінок?", Options = new List<string> { "Ігнорує частоту використання сторінок", "Потребує додаткової пам'яті", "Складний у реалізації", "Вимагає великого обсягу даних" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 97, AlgorithmId = 7, QuestionText = "Що відбувається при переповненні пам’яті у алгоритмі FIFO?", Options = new List<string> { "Сторінка, яка перебуває у пам’яті найдовше, видаляється", "Сторінка з найвищим пріоритетом видаляється", "Сторінка з найменшим доступом видаляється", "Нічого не відбувається" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 98, AlgorithmId = 7, QuestionText = "Яка структура даних найкраще підходить для реалізації FIFO алгоритму?", Options = new List<string> { "Черга", "Стека", "Хеш-таблиця", "Дерево" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 99, AlgorithmId = 7, QuestionText = "У чому полягає перевага FIFO у порівнянні з більш складними алгоритмами?", Options = new List<string> { "Простота реалізації", "Висока ефективність", "Мінімізація витрат пам’яті", "Швидке виконання" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 100, AlgorithmId = 7, QuestionText = "Який недолік FIFO може вплинути на продуктивність?", Options = new List<string> { "Можливість аномалії Бела", "Складність реалізації", "Велика кількість помилок сторінок", "Високе споживання ресурсів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 101, AlgorithmId = 7, QuestionText = "Що відбувається з новою сторінкою у FIFO, коли пам'ять повністю заповнена?", Options = new List<string> { "Вона замінює сторінку, яка перебувала найдовше", "Вона додається у кінець черги", "Вона ігнорується", "Вона замінює сторінку з найменшим доступом" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 102, AlgorithmId = 7, QuestionText = "Як аномалія Бела впливає на алгоритм FIFO?", Options = new List<string> { "Збільшує кількість помилок сторінок при збільшенні кадрів", "Зменшує продуктивність системи", "Покращує управління ресурсами", "Впливає тільки при малих обсягах пам’яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 103, AlgorithmId = 7, QuestionText = "У яких випадках алгоритм FIFO може бути менш ефективним?", Options = new List<string> { "Коли доступ до даних є нерівномірним", "Коли всі сторінки мають однаковий час доступу", "Коли використовується великий обсяг пам’яті", "Коли система має обмежені ресурси" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 104, AlgorithmId = 7, QuestionText = "Що є ключовим фактором у прийнятті рішень у алгоритмі FIFO?", Options = new List<string> { "Час завантаження сторінки", "Частота використання сторінки", "Об’єм пам’яті сторінки", "Пріоритет сторінки" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 105, AlgorithmId = 7, QuestionText = "Які кроки включає реалізація алгоритму FIFO?", Options = new List<string> { "Створення черги, додавання нових сторінок, видалення старих сторінок", "Визначення пріоритетів сторінок", "Аналіз частоти доступу до сторінок", "Розподіл ресурсів між процесами" }, CorrectOptionIndex = 0 },

                //Clock
                new TestQuestion { Id = 106, AlgorithmId = 8, QuestionText = "Яка основна мета алгоритму Clock?", Options = new List<string> { "Оптимізація заміщення сторінок", "Зменшення часу виконання процесів", "Управління процесами", "Забезпечення доступу до пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 107, AlgorithmId = 8, QuestionText = "Яка структура даних використовується в алгоритмі Clock?", Options = new List<string> { "Кільцевий буфер", "Стек", "Черга", "Масив" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 108, AlgorithmId = 8, QuestionText = "Що означає 'бит доступу' у алгоритмі Clock?", Options = new List<string> { "Індикація використання сторінки", "Пріоритет процесу", "Кількість доступів до сторінки", "Індикація розміру сторінки" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 109, AlgorithmId = 8, QuestionText = "Який крок виконується, якщо сторінка з битом доступу = 1 знайдена?", Options = new List<string> { "Бит скидається в 0", "Сторінка видаляється", "Нічого не відбувається", "Додається новий процес" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 110, AlgorithmId = 8, QuestionText = "Яка перевага алгоритму Clock?", Options = new List<string> { "Менша кількість записів у пам'ять", "Висока точність", "Простота реалізації", "Мінімальне споживання ресурсів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 111, AlgorithmId = 8, QuestionText = "Чому алгоритм Clock є покращенням FIFO?", Options = new List<string> { "Він враховує частоту використання сторінок", "Використовує додаткові ресурси", "Менше залежить від кількості процесів", "Зменшує час обробки" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 112, AlgorithmId = 8, QuestionText = "Що відбувається, якщо сторінка з битом доступу = 0 знайдена?", Options = new List<string> { "Сторінка заміщується", "Бит змінюється на 1", "Сторінка видаляється", "Сторінка переміщується на початок черги" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 113, AlgorithmId = 8, QuestionText = "Який недолік має алгоритм Clock?", Options = new List<string> { "Складність реалізації", "Низька точність при великій кількості сторінок", "Високе споживання пам'яті", "Невисока швидкість доступу" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 114, AlgorithmId = 8, QuestionText = "Що символізує стрілка в алгоритмі Clock?", Options = new List<string> { "Поточну позицію для заміщення", "Позицію першого процесу", "Кінець черги", "Стан сторінки" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 115, AlgorithmId = 8, QuestionText = "Які фактори впливають на ефективність алгоритму Clock?", Options = new List<string> { "Розмір сторінки та доступність пам'яті", "Кількість процесів", "Швидкість процесора", "Розмір коду" }, CorrectOptionIndex = 0 },

                //LRU
                new TestQuestion { Id = 116, AlgorithmId = 9, QuestionText = "Що означає 'LRU' у контексті заміщення сторінок?", Options = new List<string> { "Least Recently Used", "Latest Required Update", "Low Resource Usage", "Last Read Update" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 117, AlgorithmId = 9, QuestionText = "Який принцип роботи алгоритму LRU?", Options = new List<string> { "Заміщення сторінки, яка найдавніше використовувалася", "Заміщення сторінки з найвищим пріоритетом", "Заміщення сторінки за порядком", "Видалення сторінок з пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 118, AlgorithmId = 9, QuestionText = "Який недолік має класичний LRU?", Options = new List<string> { "Висока вартість реалізації", "Низька точність", "Складність управління пам'яттю", "Високе споживання пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 119, AlgorithmId = 9, QuestionText = "Що використовують для відстеження часу використання сторінок у LRU?", Options = new List<string> { "Масиви або стек", "Біт доступу", "Таблицю індексів", "Чергу" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 120, AlgorithmId = 9, QuestionText = "Яка перевага алгоритму LRU?", Options = new List<string> { "Мінімізація пропущених сторінок", "Простота реалізації", "Швидкість доступу", "Зменшення споживання ресурсів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 121, AlgorithmId = 9, QuestionText = "Чим LRU кращий за FIFO?", Options = new List<string> { "Враховує частоту використання сторінок", "Менше споживає пам'яті", "Швидше працює", "Простота реалізації" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 122, AlgorithmId = 9, QuestionText = "Що відбувається зі сторінкою, яка не використовувалася найдовше?", Options = new List<string> { "Вона заміщується", "Переміщується на початок черги", "Залишається на місці", "Видаляється" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 123, AlgorithmId = 9, QuestionText = "У яких випадках LRU є менш ефективним?", Options = new List<string> { "При великій кількості процесів", "При однакових пріоритетах сторінок", "При використанні великих масивів даних", "При низькому навантаженні на пам'ять" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 124, AlgorithmId = 9, QuestionText = "Що може викликати проблему з продуктивністю в алгоритмі LRU?", Options = new List<string> { "Часті оновлення часу доступу", "Малі об'єми пам'яті", "Великі індекси сторінок", "Нерівномірний доступ до сторінок" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 125, AlgorithmId = 9, QuestionText = "Яка основна мета алгоритму LRU?", Options = new List<string> { "Зменшення кількості пропущених сторінок", "Прискорення доступу до сторінок", "Зменшення ресурсів пам'яті", "Забезпечення справедливості" }, CorrectOptionIndex = 0 },

                //LRU(stack)
                new TestQuestion { Id = 126, AlgorithmId = 10, QuestionText = "Яка структура даних використовується у реалізації LRU (stack)?", Options = new List<string> { "Стек", "Черга", "Масив", "Кільцевий буфер" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 127, AlgorithmId = 10, QuestionText = "Що відбувається зі сторінкою, коли вона використовується у LRU (stack)?", Options = new List<string> { "Переміщується на вершину стеку", "Видаляється", "Додається в кінець черги", "Залишається на місці" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 128, AlgorithmId = 10, QuestionText = "Чим LRU (stack) відрізняється від класичного LRU?", Options = new List<string> { "Оптимізованою структурою даних", "Меншою точністю", "Зменшеним споживанням пам'яті", "Швидшим доступом до даних" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 129, AlgorithmId = 10, QuestionText = "Яка перевага використання стеку в алгоритмі LRU (stack)?", Options = new List<string> { "Швидке переміщення даних", "Простота управління пам'яттю", "Зменшення часу виконання", "Оптимізація процесів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 130, AlgorithmId = 10, QuestionText = "Що є недоліком алгоритму LRU (stack)?", Options = new List<string> { "Складність реалізації", "Висока витрата пам'яті", "Низька ефективність", "Висока кількість помилок заміщення" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 131, AlgorithmId = 10, QuestionText = "Що трапляється зі сторінкою у нижній частині стеку?", Options = new List<string> { "Вона заміщується", "Переміщується у верхню частину", "Видаляється", "Залишається без змін" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 132, AlgorithmId = 10, QuestionText = "Які фактори впливають на ефективність LRU (stack)?", Options = new List<string> { "Розмір стеку та частота доступу", "Кількість сторінок", "Швидкість процесора", "Об'єм пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 133, AlgorithmId = 10, QuestionText = "Як забезпечується оновлення стеку у LRU (stack)?", Options = new List<string> { "Переміщенням сторінки на вершину при використанні", "Видаленням старих сторінок", "Додаванням нових сторінок", "Використанням таблиць доступу" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 134, AlgorithmId = 10, QuestionText = "Яка головна мета LRU (stack)?", Options = new List<string> { "Ефективне управління заміщенням сторінок", "Зменшення ресурсів пам'яті", "Прискорення виконання процесів", "Покращення структури даних" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 135, AlgorithmId = 10, QuestionText = "Який вплив має розмір стеку на алгоритм LRU (stack)?", Options = new List<string> { "Визначає кількість сторінок, які можна відслідковувати", "Зменшує кількість помилок", "Прискорює доступ до даних", "Зменшує складність алгоритму" }, CorrectOptionIndex = 0 },

                //LFU
                new TestQuestion { Id = 136, AlgorithmId = 11, QuestionText = "Який основний принцип роботи алгоритму LFU?", Options = new List<string> { "Видаляє сторінку з найменшою частотою використання", "Зберігає всі сторінки в пам'яті", "Видаляє сторінку з найбільшим пріоритетом", "Використовує круговий буфер для заміщення" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 137, AlgorithmId = 11, QuestionText = "Як LFU вирішує конфлікт, якщо декілька сторінок мають однакову частоту використання?", Options = new List<string> { "Використовує часовий маркер", "Видаляє першу сторінку у списку", "Не заміщує сторінки", "Видаляє сторінку випадковим чином" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 138, AlgorithmId = 11, QuestionText = "Який недолік LFU у сценаріях з нерегулярним доступом до сторінок?", Options = new List<string> { "Часто викликає непотрібну заміну сторінок", "Занадто простий для складних систем", "Не працює з великими масивами даних", "Використовує занадто багато пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 139, AlgorithmId = 11, QuestionText = "Як алгоритм LFU поводиться зі сторінками, які були використані лише один раз?", Options = new List<string> { "Видаляє їх першими", "Залишає їх у пам'яті", "Підвищує їх частоту використання", "Зберігає як найбільш важливі" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 140, AlgorithmId = 11, QuestionText = "Чи підходить LFU для робочих навантажень, які потребують швидкого доступу до даних?", Options = new List<string> { "Не завжди через накладні витрати на підрахунок частот", "Так, завжди", "Лише у багатопотокових середовищах", "Лише у системах реального часу" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 141, AlgorithmId = 11, QuestionText = "Як можна оптимізувати роботу алгоритму LFU?", Options = new List<string> { "Використовувати гібридні підходи, такі як LFU-LRU", "Не проводити заміну сторінок", "Збільшити розмір кешу", "Використовувати менше пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 142, AlgorithmId = 11, QuestionText = "Чому LFU може призводити до 'застиглих' сторінок (stale pages)?", Options = new List<string> { "Через збереження сторінок з історично високою частотою", "Через постійне оновлення частот", "Через випадковий вибір сторінок", "Через використання часових міток" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 143, AlgorithmId = 11, QuestionText = "У чому різниця між LFU та LRU?", Options = new List<string> { "LFU використовує частоти, а LRU — час останнього доступу", "LFU складніший за LRU", "LFU менш ефективний за LRU", "LRU працює швидше за LFU у всіх випадках" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 144, AlgorithmId = 11, QuestionText = "Яка структура даних найчастіше використовується для реалізації LFU?", Options = new List<string> { "Хеш-таблиця з пріоритетною чергою", "Однозв’язний список", "Круговий буфер", "Множина" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 145, AlgorithmId = 11, QuestionText = "Як змінюється частота використання у LFU?", Options = new List<string> { "Збільшується кожного разу, коли сторінка використовується", "Зменшується через певний час", "Рівномірно оновлюється для всіх сторінок", "Встановлюється вручну" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 146, AlgorithmId = 11, QuestionText = "Як час виконання LFU змінюється зі збільшенням кількості сторінок?", Options = new List<string> { "Зростає лінійно", "Зростає експоненційно", "Не змінюється", "Знижується" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 147, AlgorithmId = 11, QuestionText = "Як LFU може працювати в середовищах реального часу?", Options = new List<string> { "Може використовуватися з оптимізаціями, наприклад, обмеження оновлень частот", "Не може працювати в реальному часі", "Тільки з LRU як допоміжним алгоритмом", "За умови постійного очищення кешу" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 148, AlgorithmId = 11, QuestionText = "Як працює адаптивний LFU?", Options = new List<string> { "Зменшує вплив історичних частот", "Підвищує пріоритет нових сторінок", "Видаляє найстаріші сторінки", "Використовує випадкову заміну" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 149, AlgorithmId = 11, QuestionText = "Яке середовище краще підходить для використання LFU?", Options = new List<string> { "Системи з повторюваними шаблонами доступу до даних", "Системи реального часу", "Однозадачні системи", "Системи з рідким доступом до даних" }, CorrectOptionIndex = 0 },

                //MFU
                new TestQuestion { Id = 150, AlgorithmId = 12, QuestionText = "Який основний принцип роботи алгоритму MFU?", Options = new List<string> { "Видаляє сторінку з найвищою частотою використання", "Зберігає всі сторінки у пам'яті", "Видаляє сторінку з найменшим пріоритетом", "Використовує часовий маркер" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 151, AlgorithmId = 12, QuestionText = "Чому алгоритм MFU може бути неефективним у деяких сценаріях?", Options = new List<string> { "Часто видаляє сторінки, які все ще потрібні", "Вимагає значного обсягу пам'яті", "Не підтримує частоти доступу", "Працює лише у великих системах" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 152, AlgorithmId = 12, QuestionText = "Як MFU вирішує конфлікт, якщо декілька сторінок мають однакову частоту використання?", Options = new List<string> { "Використовує часовий маркер", "Видаляє першу сторінку у списку", "Не заміщує сторінки", "Видаляє сторінку випадковим чином" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 153, AlgorithmId = 12, QuestionText = "Яка структура даних найчастіше використовується для реалізації MFU?", Options = new List<string> { "Хеш-таблиця з пріоритетною чергою", "Круговий буфер", "Однозв'язний список", "Двовимірний масив" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 154, AlgorithmId = 12, QuestionText = "Як MFU поводиться зі сторінками, які використовувалися багато разів?", Options = new List<string> { "Видаляє їх у першу чергу", "Залишає у пам'яті", "Переміщує їх до кінця списку", "Об'єднує з іншими сторінками" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 155, AlgorithmId = 12, QuestionText = "Чи може MFU працювати ефективно в системах реального часу?", Options = new List<string> { "Рідко через повільну реакцію на зміну доступу до даних", "Завжди ефективно", "Лише у багатозадачних середовищах", "Не підтримує реальний час" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 156, AlgorithmId = 12, QuestionText = "Який недолік MFU у середовищах з невеликою кількістю сторінок?", Options = new List<string> { "Часто замінює необхідні сторінки", "Вимагає багато часу для аналізу", "Працює лише з LRU як допоміжним алгоритмом", "Має високу вартість обчислень" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 157, AlgorithmId = 12, QuestionText = "Яка головна різниця між LFU та MFU?", Options = new List<string> { "LFU видаляє найменш використовувану сторінку, MFU — найчастіше використовувану", "LFU працює швидше", "MFU використовує менше пам'яті", "У них однаковий принцип роботи" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 158, AlgorithmId = 12, QuestionText = "Як змінюється частота доступу у MFU?", Options = new List<string> { "Збільшується кожного разу, коли сторінка використовується", "Зменшується через певний час", "Не змінюється", "Встановлюється вручну" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 159, AlgorithmId = 12, QuestionText = "Яка основна сфера застосування MFU?", Options = new List<string> { "Системи, де часто використовувані сторінки швидко стають застарілими", "Системи реального часу", "Великі бази даних", "Системи з великими обсягами пам'яті" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 160, AlgorithmId = 12, QuestionText = "Чи можна оптимізувати MFU для сучасних систем?", Options = new List<string> { "Так, за допомогою адаптивного підходу", "Ні, алгоритм занадто простий", "Тільки для багатопотокових додатків", "Тільки за наявності швидкого обладнання" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 161, AlgorithmId = 12, QuestionText = "Які проблеми виникають при використанні MFU у великих системах?", Options = new List<string> { "Висока складність обчислень", "Не працює з великими обсягами даних", "Вимагає надто мало ресурсів", "Має високу швидкість заміщення" }, CorrectOptionIndex = 0 },

                //Banker
                new TestQuestion { Id = 162, AlgorithmId = 13, QuestionText = "Як алгоритм банкіра обчислює потребу процесу в ресурсах?", Options = new List<string> { "Віднімає поточний розподіл від максимальної потреби", "Сумує всі запити процесів", "Подвоює кількість запитуваних ресурсів", "Додає всі вільні ресурси до поточних" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 163, AlgorithmId = 13, QuestionText = "Що відбувається, якщо процес запитує більше ресурсів, ніж дозволяє алгоритм банкіра?", Options = new List<string> { "Запит відхиляється", "Процес завершується", "Система входить у стан блокування", "Запит виконується частково" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 164, AlgorithmId = 13, QuestionText = "Чи може алгоритм банкіра працювати з динамічно змінюваними ресурсами?", Options = new List<string> { "Так, якщо оновлюється безпечний стан", "Ні, ресурси мають бути статичними", "Лише у багатопроцесорних системах", "Тільки з фіксованою кількістю процесів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 165, AlgorithmId = 13, QuestionText = "Як алгоритм банкіра визначає, чи безпечний поточний стан?", Options = new List<string> { "Шукає безпечну послідовність виконання процесів", "Виконує всі процеси одночасно", "Аналізує лише перший процес", "Ігнорує невикористані ресурси" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 166, AlgorithmId = 13, QuestionText = "Який реальний приклад відповідає роботі алгоритму банкіра?", Options = new List<string> { "Кредитна система банку", "Черга на отримання квитків", "Алгоритм шифрування даних", "Пріоритетне сортування завдань" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 167, AlgorithmId = 13, QuestionText = "Що станеться, якщо система перебуває у небезпечному стані?", Options = new List<string> { "Є ризик виникнення стану блокування", "Процеси будуть завершені", "Ресурси будуть розподілені повторно", "Запити не оброблятимуться" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 168, AlgorithmId = 13, QuestionText = "Чи можна використовувати алгоритм банкіра для уникнення взаємного блокування у розподілених системах?", Options = new List<string> { "Ні, алгоритм розрахований на локальні системи", "Так, без змін у коді", "Тільки з фіксованим розподілом ресурсів", "Лише при збільшенні кількості ресурсів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 169, AlgorithmId = 13, QuestionText = "Яка складність алгоритму банкіра у найгіршому випадку?", Options = new List<string> { "O(n^2)", "O(n)", "O(log n)", "O(n*m), де n — кількість процесів, m — типів ресурсів" }, CorrectOptionIndex = 3 },
                new TestQuestion { Id = 170, AlgorithmId = 13, QuestionText = "Чи може алгоритм банкіра працювати у режимі реального часу?", Options = new List<string> { "Рідко, через складність перевірки безпеки", "Завжди", "Тільки у багатозадачних середовищах", "Лише за умови фіксованого розподілу" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 171, AlgorithmId = 13, QuestionText = "Як алгоритм банкіра реагує на запити ресурсів, які перевищують максимальну потребу процесу?", Options = new List<string> { "Запит негайно відхиляється", "Розподіл ресурсів виконується частково", "Система переходить у стан блокування", "Процес завершується" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 172, AlgorithmId = 13, QuestionText = "Чому важливо перевіряти безпечність стану перед виконанням запиту?", Options = new List<string> { "Щоб уникнути взаємного блокування", "Для прискорення виконання запиту", "Для зменшення використання пам’яті", "Щоб запобігти помилкам у процесах" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 173, AlgorithmId = 13, QuestionText = "Що є основною перевагою алгоритму банкіра?", Options = new List<string> { "Уникнення взаємного блокування", "Швидке розподілення ресурсів", "Мінімальне використання пам’яті", "Можливість динамічного додавання процесів" }, CorrectOptionIndex = 0 },
                new TestQuestion { Id = 174, AlgorithmId = 13, QuestionText = "Чи є алгоритм банкіра оптимальним для великих систем?", Options = new List<string> { "Ні, через складність перевірки безпеки", "Так, завжди оптимальний", "Лише для статичних ресурсів", "Тільки у малих системах" }, CorrectOptionIndex = 0 }
            };
        }
    }
}
